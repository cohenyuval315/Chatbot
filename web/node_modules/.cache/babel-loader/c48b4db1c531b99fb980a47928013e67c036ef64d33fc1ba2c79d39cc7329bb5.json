{"ast":null,"code":"import { v4 as uuid } from \"uuid\";\nclass APIClient {\n  constructor() {\n    this.instance = null;\n    this._request = async (method, endpoint, body = null) => {\n      const requestOptions = {\n        method: method,\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      };\n      if (body !== null) {\n        requestOptions.body = JSON.stringify(body);\n      }\n      try {\n        const response = await fetch(`${this.base_url}${endpoint}`, requestOptions);\n        const data = await response.json();\n        if (response.ok) {\n          return data;\n        } else {\n          console.error(`Request failed with status ${response.status}: ${data.message}`);\n          throw new Error(data.message || 'An error occurred during the request.');\n        }\n      } catch (error) {\n        console.error(error.message);\n        throw error; // Re-throw the error so the calling function can handle it\n      }\n    };\n    if (APIClient.instance === null) {\n      APIClient.instance = this;\n      this.host = \"localhost\";\n      this.port = 3001;\n      this.base_url = `${this.host}:${this.port}`;\n    }\n  }\n  async fetchChats() {\n    // get /c\n    const path = \"/c\";\n    const method = \"GET\";\n    const url = this.base_url + path;\n    const response = await fetch(url, {\n      method: method,\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    const res = await response.json();\n    if (res.statusCode !== 200) {\n      return [];\n    } else {\n      return res.data;\n    }\n    const chatData = [{\n      \"id\": uuid(),\n      \"title\": \"hello\",\n      \"log\": [{\n        id: uuid(),\n        prompt: \"text1(user)\",\n        response: \"text1(bot)\"\n      }, {\n        id: uuid(),\n        prompt: \"text2(user)\",\n        response: \"text2(bot)\"\n      }]\n    }, {\n      \"id\": uuid(),\n      \"title\": \"hello2\",\n      \"log\": [{\n        id: uuid(),\n        prompt: \"text3(user)\",\n        response: \"text1(bot)\"\n      }, {\n        id: uuid(),\n        prompt: \"text2(user)\",\n        response: \"text2(bot)\"\n      }]\n    }];\n    await this.sleep(1000);\n    return chatData;\n  }\n  sleep(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n  async converse(chat, prompt) {\n    const chat_id = chat.id;\n    if (!chat_id) {\n      return await self.create_new_chat(prompt);\n    } else {\n      return await self.update_chat(chat_id, prompt);\n    }\n  }\n  async create_new_chat(prompt) {\n    const path = \"/c\";\n    const method = \"POST\";\n    const url = this.base_url + path;\n    const data = {\n      \"prompt\": prompt\n    };\n    const response = await fetch(url, {\n      method: method,\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data)\n    });\n    const res = await response.json();\n    if (res.statusCode !== 200) {\n      return res.message;\n    } else {\n      return res.data;\n    }\n  }\n  async update_chat(chat_id, prompt) {\n    const path = `/c/${chat_id}`;\n    const method = \"PUT\";\n    const url = this.base_url + path;\n    const data = {\n      \"prompt\": prompt\n    };\n    const response = await fetch(url, {\n      method: method,\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data)\n    });\n    const res = await response.json();\n    if (res.statusCode !== 200) {\n      return res.message;\n    } else {\n      return res.data;\n    }\n  }\n}\nlet client = new APIClient();\nexport default client;","map":{"version":3,"names":["v4","uuid","APIClient","constructor","instance","_request","method","endpoint","body","requestOptions","headers","JSON","stringify","response","fetch","base_url","data","json","ok","console","error","status","message","Error","host","port","fetchChats","path","url","res","statusCode","chatData","id","prompt","sleep","ms","Promise","resolve","setTimeout","converse","chat","chat_id","self","create_new_chat","update_chat","client"],"sources":["/home/yuval/Desktop/chatbot_app/Chatbot/web/src/API/APIClient.jsx"],"sourcesContent":["import { v4 as uuid } from \"uuid\";\n\nclass APIClient {\n    instance = null; \n    constructor() {  \n        if (APIClient.instance === null) {\n\n            APIClient.instance = this;\n            this.host = \"localhost\"\n            this.port = 3001\n            this.base_url = `${this.host}:${this.port}`;\n        }\n    }\n\n  _request = async (method,endpoint, body = null) => {\n    const requestOptions = {\n      method: method,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n    };\n    if (body !== null) {\n      requestOptions.body = JSON.stringify(body);\n    }\n  \n    try {\n      const response = await fetch(`${this.base_url}${endpoint}`, requestOptions);\n      const data = await response.json();\n      if (response.ok) {\n        return data; \n      } else {\n        console.error(`Request failed with status ${response.status}: ${data.message}`);\n      \n        throw new Error(data.message || 'An error occurred during the request.');\n      }\n    } catch (error) {\n      console.error(error.message);\n      throw error; // Re-throw the error so the calling function can handle it\n    }\n  }\n    async fetchChats() {\n      // get /c\n      const path = \"/c\"\n      const method = \"GET\"\n      const url = this.base_url + path\n      const response = await fetch(url, {\n        method: method,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        }\n      });\n      const res = await response.json();\n      if (res.statusCode !== 200){\n        return []\n      }else{\n        return res.data\n      }\n\n        const chatData = [\n            {\n              \"id\":uuid(),\n              \"title\":\"hello\",\n              \"log\": [\n                {\n                  id:uuid(),\n                  prompt:\"text1(user)\",\n                  response:\"text1(bot)\",\n                },\n                {\n                  id:uuid(),\n                  prompt:\"text2(user)\",\n                  response:\"text2(bot)\",\n                }          \n              ]\n            },\n            {\n              \"id\":uuid(),\n              \"title\":\"hello2\",\n              \"log\": [\n                {\n                  id:uuid(),\n                  prompt:\"text3(user)\",\n                  response:\"text1(bot)\",\n                },\n                {\n                  id:uuid(),\n                  prompt:\"text2(user)\",\n                  response:\"text2(bot)\",\n                }          \n              ]\n            }\n        ]\n        await this.sleep(1000);\n        return chatData\n    }\n\n    sleep(ms) {\n      return new Promise(resolve => {\n        setTimeout(resolve, ms);\n      });\n    }\n    \n    async converse(chat,prompt){\n      const chat_id = chat.id\n      if (!chat_id){\n        return await self.create_new_chat(prompt)\n      }else{\n        return await self.update_chat(chat_id,prompt)\n      }\n    }\n\n    async create_new_chat(prompt){\n      const path = \"/c\"\n      const method = \"POST\"\n      const url = this.base_url + path\n      const data = {\n        \"prompt\":prompt\n      }\n      const response = await fetch(url, {\n        method: method,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      });\n      const res = await response.json();\n      if (res.statusCode !== 200){\n        return res.message\n      }else{\n        return res.data\n      }\n    }\n\n    async update_chat(chat_id,prompt){\n      const path = `/c/${chat_id}`\n      const method = \"PUT\"\n      const url = this.base_url + path\n      const data = {\n        \"prompt\":prompt\n      }\n      const response = await fetch(url, {\n        method: method,\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      });\n      const res = await response.json();\n      if (res.statusCode !== 200){\n        return res.message\n      }else{\n        return res.data\n      }\n    }\n\n}\n\n\nlet client = new APIClient();\n\n\nexport default client;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}